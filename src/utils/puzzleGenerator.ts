import type { TileValue } from '@/types/game';

// Calculates the number of inversions in a sliding puzzle board.
// An inversion is a pair of tiles (a, b) such that a appears before b,
// but a > b. This function helps determine whether the puzzle is solvable.
// https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/

export const countInversions = (array: TileValue[]): number => {
  const numbers = array.filter((n): n is number => n !== null);
  return numbers.reduce((inv, current, i) => {
    const inversionsForCurrent = numbers
      .slice(i + 1)
      .filter((next) => current > next).length;
    return inv + inversionsForCurrent;
  }, 0);
};

// Determines if a sliding puzzle is solvable based on the number of inversions
// and the position of the blank tile.
export const isSolvable = (
  board: TileValue[],
  rows: number,
  cols: number
): boolean => {
  const inversions = countInversions(board);
  const blankIndex = board.indexOf(null);
  const blankRow = Math.floor(blankIndex / cols);
  const blankRowFromBottom = rows - blankRow;

  if (cols % 2 === 1) {
    // Odd width: solvable if inversions is even
    return inversions % 2 === 0;
  } else {
    // Even width:
    if (blankRowFromBottom % 2 === 0) {
      return inversions % 2 === 1;
    } else {
      return inversions % 2 === 0;
    }
  }
};

// Generates a flat array of tiles for a sliding puzzle.
// The array includes all numbers from 1 to (rows * cols - 1) and a null tile.
export const generateTiles = (rows: number, cols: number): TileValue[] => {
  const total = rows * cols;
  return [...Array.from({ length: total - 1 }, (_, i) => i + 1), null];
};

// Shuffles the tiles in a sliding puzzle.
export const shuffleTiles = (array: TileValue[]): TileValue[] => {
  return array
    .map((value) => ({ value, sort: Math.random() }))
    .sort((a, b) => a.sort - b.sort)
    .map(({ value }) => value);
};

// Generates a solvable sliding puzzle.
// The puzzle is generated by shuffling the tiles and then checking if the puzzle is solvable.
// If the puzzle is not solvable, it shuffles again until it is.
export const generateSolvablePuzzle = (
  rows: number,
  cols: number
): TileValue[] => {
  const tiles = generateTiles(rows, cols);
  let shuffled: TileValue[];

  do {
    shuffled = shuffleTiles(tiles);
  } while (!isSolvable(shuffled, rows, cols));

  return shuffled;
};
